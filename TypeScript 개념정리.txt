 - TypeScript
    : Microsoft에서 개발한 JavaScript의 동적타입(Dynamic typing)적인 측면으로 인한 문제점을 보완한 확장된 버전의 정적 타입 프로그래밍 언어
      (= JS에서 타입 문법을 보완하여 업그레이드해서 쓸 수 있는 JS의 업드레이판 언어 or 일종의 부가기능라고 생각하면 편함..)

     # TypeScript 특징
         : TS는 정적타입(Static typing) 언어 + 컴파일 언어
            -> 이를 통해 JS도 타 언어들과 같은 안정성을 가질 수 있게 되었음

                1) TypeScript는 정적 타입 언어라서 변수하나 선언 시, 그 때마다 타입을 명시해야 함

                2) 브라우저는 JS만 인식할 수 있으므로, JS로 Complie을 해줘서 JS로 변환을 해줘야 함
                    -> CSS와 전처리기인 Sass, JSX와 JS의 관계와 유사한 관계 맞음

                3) TypeScript는 자료형마다 가능한 기능을 확실하게 제한함
                   (= 선언된 변수에 어떤 기능이나 함수를 적용하려면, 그 기능에 허용된 자료형에 해당 변수가 해당되어야 함)
                       -> 만약, 변수에 어떤 자료형의 값이 들어있는지 모른다면? 조작할 변수의 타입이 무엇인지 확실하게 체크(narrowing 또는 assertion)해야 함

                4) TypeScript를 컴파일하면 JS로 작성되기에, JS는 호환성이 높은 편에 속하는 언어
                    -> BUT! JS에서는 가능한게 TS에서는 안 되는게 존재하기에 완전히 같은 언어에 호환성이 존재한다고 말하긴 힘듦

                        ex) class 선언시 멤버변수가 없는데, 메서드에 this.변수명을 적으면, JS는 자동으로 그 변수를 프로퍼티로 추가하나, TS는 칼같이 잡아내고 수정하라고 함
                            (= 애초에 애매한거 확실하게 하자는 취지로 개발된 언어가 TypeScript이기 때문)


     # TypeScript의 등장 이유?
        : JS는 강제형변환을 통해 능동적으로 타입을 변경 가능한 동적타입(Dynamic typing) 언어 + 인터프리터 언어 =  오류가 발생해도 런타임 중에 발생함
          (= 강제 형변환 적용이 예측이 힘들어서, 디버깅도 힘들고 어디서 사람이 뭘 잘못했는지에 대해 정적타입 언어에 비해 판별이 힘들다는 단점 존재)
              -> 그렇다면? 이 그 문제를 고치자 해서 등장한 언어가 'TypeScript'.. 타입 관련된 에러 메시지가 더 친절함
                 (협업시, 남이 짠 코드가 어마무시할때는 정적타입 규칙이 적용된다는거 하나만으로도 굉장히 큰 이점이기 때문)

                 ex) JS의 문제점을 보여주는 예시1

                      function showItems(arr){
                        arr.foreach((item) => {
                          console.log(item);
                        });
                      }

                      showItems(1,2,3);   <- 파라미터가 배열이 아니기에 foreach를 적용할 수 없는것을 런타임때 가서야 알아냄.. 
                                               -> 만약 파라미터의 타입을 정적으로 명시할 수 있고, 이를 사전에 감지할 수 있으면 얼마나 좋을까???

     # 일반적으로 typescript 설치 & 사용법
       1. node js 설치

       2. 터미널에 npm install -g typescript 입력하여, 전역 라이브러리로서 typescript Complier(타입스크립트 컴파일러) 설치
           -> 이렇게 하면, 작업폴더마다 typescript Complier를 설치하지 않아도 된다는 이점이 존재

       3. (중요) 작업폴더에 tsconfig.json 파일을 생성하고, json형식으로 내용을 입력
            -> 속성에 대한 자세한 내용들은 https://www.typescriptlang.org/tsconfig 참고

               @ target (필수)
                   : TS파일을 JS로 컴파일할시 어떤 JS버전으로 컴파일 할지를 의미    
                      ex) es숫자, es년도, esnext는 최신 JS버전 의미
    
               @ module (필수)
                   : 어떤 JS 모듈 시스템을 쓸건지를 의미   
                      ex) esnext(import 문법), commonjs(require 문법)  <- Node는 이걸 기준으로 쓰는 중이니 참고하자
    
               ex) { 
                     "compilerOptions" : {
                        "target": "es5",            // 'es3', 'es5', 'es2015', 'es2016', 'es2017','es2018', 'esnext' 가능
                        "module": "commonjs",       // 무슨 import 문법 쓸건지 'commonjs', 'amd', 'es2015', 'esnext'
                        "allowJs": true,            // js 파일들 ts에서 import해서 쓸 수 있는지 
                        "checkJs": true,            // 일반 js 파일에서도 에러체크 여부 
                        "jsx": "preserve",          // tsx 파일을 jsx로 어떻게 컴파일할 것인지 'preserve', 'react-native', 'react'
                        "declaration": true,        // 컴파일시 .d.ts 파일도 자동으로 함께생성 (현재쓰는 모든 타입이 정의된 파일)
                        "outFile": "./",            // 모든 ts파일을 js파일 하나로 컴파일해줌 (module이 none, amd, system일 때만 가능)
                        "outDir": "./",             // js파일 아웃풋 경로바꾸기
                        "rootDir": "./",            // 루트경로 바꾸기 (js 파일 아웃풋 경로에 영향줌)
                        "removeComments": true,     // 컴파일시 주석제거 
                      
                        "strict": true,                         // strict 관련, noimplicit 어쩌구 관련 모드 전부 켜기
                        "noImplicitAny": true,                  // any타입 금지 여부
                        "strictNullChecks": true,               // null, undefined 타입에 이상한 짓 할시 에러내기 
                        "strictFunctionTypes": true,            // 함수파라미터 타입체크 강하게 
                        "strictPropertyInitialization": true,   // class constructor 작성시 타입체크 강하게
                        "noImplicitThis": true,                 // this 키워드가 any 타입일 경우 에러내기
                        "alwaysStrict": true,                   // 자바스크립트 "use strict" 모드 켜기
                      
                        "noUnusedLocals": true,                 // 쓰지않는 지역변수 있으면 에러내기
                        "noUnusedParameters": true,             // 쓰지않는 파라미터 있으면 에러내기
                        "noImplicitReturns": true,              // 함수에서 return 빼먹으면 에러내기 
                        "noFallthroughCasesInSwitch": true,     // switch문 이상하면 에러내기 
                     }
                   }

       3. 작업폴더에 .ts로 끝나는 파일 만들고, typescript 문법으로 typescript 작성

       4. 작성한 TS확장자의 typescript 파일을  js확장자 파일로 변환(compile) 방법을 거침
           1) 자동으로 해당 폴더의 ts파일들을 검색해서 js 파일로 근처에 변환(compile)하도록 유도
               : 터미널에 tsc -w 입력

           2) 수동으로 해당 파일만 TS -> JS 변환(compile)
               : 터미널에 tsc TS파일명.ts 입력
           
           3) JS로 컴파일이 싫다 싶으면 다음과 같은 옵션을 써도 됨
               - https://www.typescriptlang.org/ 에서 실행해본다..
               - TS-node 라이브러리를 깔아서 거기서 실행
                  -> 터미널에서 npm install -g ts-node 입력하여 라이브러리 설치
                  -> ts-node TS파일명.ts 입력하여 Node에서 TS파일 실행하기
       
       5. TS -> JS로 compile된 파일을 import해서 쓰기
           1) HTML에 script태그로 연결하는 방법
           2) JS 모듈러 방식을 골라서 import하기 
 

     # React 프로젝트에서 typescript 적용
        1. 이미 있는 react 프로젝트에 추가하고 싶은 경우
            : 터미널에 npm install --save typescript @types/node @types/react @types/react-dom @types/jest 입력
                -> 이게 불안하다? yarn 패키지관리자 1.0 이상이 설치되어 있다면, yarn add라는 명령어로도 대체 가능 

        2. 새로 react 프로젝트를 만들고, typescript도 적용하고 싶은 경우
            : 터미널에 npx create-react-app my-app --template typescript 입력
    

     # vue.js 프로젝트에서 typescript 적용
        1. 터미널에 vue add typescript 입력하여, typescript Complier 라이브러리 설치
        2. typescript 사용하려는 vue.js 파일에 script 태그에 lang속성에 ts라는 속성값을 주면 됨

            ex) <script lang="ts"></script>


 - TypeScript 문법 및 기능 정리

    1. 변수(variable)에 타입 지정
        : let 변수명 : 타입명 = 값; 
           -> 이를 통해 JS변수에도 정적인 타입(= 자료형)을 부여할 수 있으며, 부적합한 값을 넣으면 에러를 발생시켜 줌
           -> const, var도 상관없음

         # (참고) 자동 형변환이라는 무기를 가지는 JS의 특성을 TypeScript도 어느정도 반영해서...
             -> 얘도 꼭 :타입명을 변수에 지정하지 않아도, 변수에 할당한 값을 통해 타입을 추론(Type Inference)해서 주기도 함

                 ex) let 이름 = 'kim';     <- 'kim'에서 string이라고 자료형을 유추하고, string 타입으로 자료형 부여
                     let 나이 = 20;        <- 20에서 number라고 자료형을 유추하고, number 타입으로 자료형 부여
                     
         # TypeScript에서 사용가능한 타입(= 자료형)

            1) 기본 자료형(= primitive types)
                : 선언된 변수에 실제 값이 저장되는 자료형 (단, string은 참조 자료형이지만, 기본처럼 쓰임)
                   - string    : '문자열'만 변수에 허용         ex) let initial : string = 'lsh';
                   - number    : '숫자'만 변수에 허용           ex) let age : number = 30;
                   - boolean   : true, false 만 변수에 허용     ex) let isAdult : boolean = true;
                   - null      : null만 변수에 들어감           ex) let a : null = null;
                   - undefined : undefined만 변수에 들어감      ex) let b : undefined = undefined;

                 @ (참고) 오직 number 타입만 사칙연산이 가능함

            2) 참조 자료형(= primitive types)
                : 선언된 변수에 값이 아닌 인스턴스에 대한 주소값이 저장되는 자료형
                   -> (참고) 배열이나 JS객체 리터럴, class, interface 내부에 들어갈 수 있는 요소들에 대해 선언 가능한 자료형은 TypeScript에서 허용하는 모든 자료형임을 명심해라
                      (= 사용자가 정의한 자료형 별명(Type Aliases)도 이에 해당함)

                   A. 배열(Array)
                       : 특정 자료형의 '배열' 형식만 변수에 허용

                         - 타입명[]      : 특정 '자료형'만 허용하는 '배열' 1    ex) let num : number[] = [1,2,3];
                         - Array<타입명> : 특정 '자료형'만 허용하는 '배열' 2    ex) let week2 : Array<string> = ['mon', 'tues', 'weds']; 

                   B. 사용자 지정 JS객체(Object literal Type)
                       : {}안에 개별 멤버변수(property)들의 자료형이 선언된 'JS객체 리터럴' 형식만 변수에 허용

                          @ (참고) 리터럴(literal) 관련 개념들
                            1. 리터럴(literal)
                               : 사람이 이해할 수 있는 문자나 약속된 기호를 사용해 값을 생성하는 표기법   

                            2. (중요!) 객체 리터럴 자료형(object literal type)과 여기서 말하는 리터럴 자료형(literal type)은 개념적으로 거의 상관관계가 없다봐도 무방함
                               : 리터럴 타입은 특정 값에 대한 제약을 주는 데 사용되고, 객체 리터럴 타입은 객체의 구조를 정의하고 검증하는 데 사용됩니다.
                                   -> JS객체 리터럴 자료형(object literal type)
                                       : TypeScript에서 JS객체의 '구조'를 정의하는 데이터 자료형을 의미

                                   -> 리터럴 자료형(literal type) 
                                       : 문자열, 숫자, 불리언 중에서도 특정한 값이 자료형 그 자체로 '제약'되는 경우의 자료형을 의미

                         - 객체명 : { 멤버변수1 : 자료형 , ... , 멤버변수n : 자료형} = { 멤버변수1 : 값1 , ... ,  멤버변수n : 값n}
                             : 멤버변수들에 직접 자료형을 대입한 무명의 JS객체 리터럴(object literal) 형식 자료형을 직접 기입, 그에 맞는 값들을 즉석에서 대입
                                -> BUT! 가독성이나, 관리 측면이나 좋을게 1도 없으니 비추 
            
                                   ex) let teacher : {
                                         name : string,
                                         age : number
                                       } = { name : 'john', age : 20 } 
            
                         - Type Aliases(별칭) 문법으로 JS객체 형식 미리 정의
                            : Type Aliases(별칭) 문법을 사용하여, 사용자 지정 객체 자료형을 별명으로 생성한 뒤, 그 별칭을 JS객체 리터럴(object literal)형식의 자료형으로 선언
                               -> 2번의 Type Aliases(별칭) 기능 참고!
                              
                                   ex) 상단의 예시와 유사하나, 객체명 : {객체} 부분을 Type Aliases(별칭) 문법으로 '사람'이란 자료형 별칭으로 선언하여 이를 자료형으로 사용했다는게 다름
                                   
                                       type 사람 = {
                                         name : string,
                                         age : number
                                       }
            
                                       let teacher : 사람 = { name : 'john', age : 20 } 

                         - interface(인터페이스) 문법으로 JS객체 형식 미리 정의
                            : interface(인터페이스) 문법을 사용하여 JS객체의 구조를 추상화하고 나면, 인터페이스명을 JS객체 리터럴(object literal)형식의 자료형으로 선언

                              ex) Type Aliases(별칭) 문법으로 '사람'이란 자료형 별칭을 만든것과 유사하나?
                                   -> interface 문법은 확장 측면에서, Type Aliases(별칭)보다 더 유연하고 어떤 변수에 리터럴 객체, 함수, 클래스를 주는 경우에 한해서 범용성이 높다는 장점이 존재함
                                      (3번의 interface(인터페이스) 기능 참고!)
                              
                                      interface 사람 = {
                                        name : string,
                                        age : number
                                      }
                
                                      let teacher : 사람 = { name : 'john', age : 20 } 

                   C. 클래스(class)
                       : 특정 class의 생성자 함수를 통해 생성된 'JS객체 형식'만 변수에 허용
                         (사실 특정 class 생성자를 쓰는 순간, TypeScript 컴파일러는 눈치것 알아먹음)

                         - class 클래스명 {
                             멤버변수1 : 자료형;
                             ...
                             멤버변수n : 자료형;
   
                             constructor(parameter1 : 자료형, ... , parameterN : 자료형){
                               this.멤버변수1 = parameter1;
                               ...
                               this.멤버변수n = parameterN;
                             }
                           
                             메서드명(parameter1 : 자료형, ... , parameterN : 자료형) : 자료형{
                               return 내용;
                             }
                           }

                           ex) Car라는 클래스 형식의 JS객체의 설계도는, string 자료형의 model , number 자료형의 price를 가지고
                                -> 그 멤버변수를 가공하는 메서드 persentage라는 number를 파라미터로 넣고 number를 반환하는 tax라는 메서드가 존재함
                           
                                   class Car {
                                     model : string;
                                     price : number;
      
                                     constructor(a :string, b :number){
                                       this.model = a;
                                       this.price = b;
                                     }
                                   
                                     tax(persentage : number) : number{
                                       return this.price * persentage;
                                     }
                                   }

                                   let car1 = new Car('소나타', 3000);                <-  class 생성자로 만들어진 객체를 담는 변수는 자료형 추론되니까 '자료형'을 적지 않아도 됨
                                   let car2 : Car = {model : 소나타', price : 3000};  <-  (중요) class를 자료형으로 지정하고 JS객체 리터럴로 이를 생성하는건 TS는 받아주는데, JS가 안 받아주니 쓰지 말자

                          @ (중요) 자식class extends 부모class
                             : extends는 class 상속을 구현하기 위한 문법으로, 부모class를 상속받은 자식class는 부모의 모든 프로퍼티와 메서드를 가지게 됨 
                               (= extends 쓰는 순간, 해당 class는 부모class의 모든 프로퍼티 또한 연관이 되어있다고 보면 됨)

                                  ex) 접근제한자 protected와 extends를 사용한 자식 class NewUser
                                  
                                      class User {
                                        protected x = 10;
                                      }
                                      
                                      class NewUser extends User {
                                        doThis(){
                                          this.x = 20;
                                        }
                                      }

                          @ (참고) class 관련 JS의 참고 개념
    
                              0. class를 설계할 때부터, 내부 멤버변수, 메서드(method), 생성자 함수(constructor)에 직접 자료형을 설정해야 함
                                  -> (참고) JS의 class는 객체지향언어의 느낌으로 JS객체를 다룰 수 있도록 만들어진 개념.. 상속까지 가면 결국 JS의 protoType 개념에 따른 상속의 다른 표현이라 보면 됨 

                              1. interface(인터페이스)를 생성하고 implements 키워드와 조합하면, class implements '인터페이스명'으로 interface를 구현시키는 방향으로 class 설계의 완성도를 높알 수 있음
                                 -> 3번의 interface(인터페이스) 기능 참고!

                              2. 메서드(method)는 해당 class와 class를 기반으로 만들어진 JS객체의 prototype에 추가
                                  -> class 클래스명() { 메서드() {~~} }  == 클래스명.protoType.메서드 = function(){~~}
    
                              3. 메서드(method)의 호출은 JS객체명.메서드명(parameter...) 식으로 입력하면 됨
    
                              4. (중요) 생성자(constructor) 함수는 return내용과 return 값에 대한 자료형 지정을 하면 안 됨
                                  -> constructor의 결과는 항상 class기반의 JS객체가 생성되게 설계되어 있기 때문
    
                              5. 생성자(constructor) 함수는 'new 클래스명(parameter1, ... , parameterN)'을 통해 JS객체를 생성하고, 그 JS객체가 존재하는 포인터를 변수에 대입
                                  -> new 연산자가 메모리를 할당해주고, 그 메모리의 포인터를 반환하는 역할을 하기에 없으면 사실상 변수와 JS객체 인스턴스는 연관이 없어짐
    
                              6. 생성자(constructor) 함수는 오버로딩이 가능함
                                 (= 생성자 함수가 1개일 필요는 1도 없음)
    
                              7. 생성자(constructor) 함수를 거치지 않고, 바로 JS객체 리터럴 형식으로 해당 class기반 객체를 만드는건 TypeScript에서는 허용이나 되나.. JS가 허용하지 않음
                                 (= (중요) class 쓸거면 생성자 함수를 꼭 거치는게 안정성에 좋다)
                                 
                              8. typescript 또한 '접근제한자(public, private, protect)'와 static 키워드를 사용가능하나, 반드시 class 선언시 그 내부의 프로퍼티들에만 사용이 가능함 
                                  -> 6번의 '접근제한자(public, private, protect)'와 7번의 'static' 키워드 참고
                              


                              10. JS에서는 class내부에 멤버변수가 없어도, 생성자 함수나 메서드에 this에 대한 지정이 동적으로 변할 수 있기에 'this.변수명' 사용에 별 지정 없음
                                   -> BUT! TS에서는 생성자 함수나 메서드 내부에 쓰인 this는 class를 의미하기에, 반드시 this.변수명을 쓸거면 멤버변수로 해당 변수명을 선언해야 함
    
                                       ex) TypeScript에서는 이러면 Person class에 name, age라는 멤버변수가 없기에 바로 에러를 뱉어냄
    
                                            class Person {
                                              constructor (){
                                                this.name = 'kim';
                                                this.age = 20;
                                              }
                                        }
                                        

            3) TypeScript의 DOM 구별 자료형
                : TypeScript에서 HTML태그들을 구분하기 위해 사용되는 자료형 
                   -> 일반적인 DOM셀렉터는 Element 자료형을 가지거나, 후손격인 HTMLElement를 일반적으로 가짐

                      @ HTMLElement 자료형  
                         : '특정한' DOM요소들을 제외하면, 대부분의 DOM요소만 들어감
                             -> 이걸 알아야 할 이유?
                                 : '변수명 instanceof HTMLElement'으로 조건문 Type Narrow로 코드 짤 때, 어떤 HTML태그는 HTMLElement 자료형에 속하지 않고, HTMLxxxElement라는 고유의 자료형을 가지고 있을 수 있기 때문

                      @ HTMLElement 이외의 자료형
                        - HTMLAnchorElement   : DOM요소가 a태그인 경우만 들어감  
                        - HTMLDivElement      : DOM요소가 Div태그인 경우만 들어감  
                        - HTMLSpanElement     : DOM요소가 Span태그인 경우만 들어감  
                        - HTMLInputElement    : DOM요소가 input태그인 경우만 들어감
                        - HTMLButtonElement   : DOM요소가 button태그인 경우만 들어감  
                        - HTMLSelectElement   : DOM요소가 select태그인 경우만 들어감  
                        - HTMLTextAreaElement : DOM요소가 textarea태그인 경우만 들어감  
                        - HTMLImageElement    : DOM요소가 img태그인 경우만 들어감
                        - HTMLTableElement    : DOM요소가 Table태그인 경우만 들어감  
                        - HTMLFormElement     : DOM요소가 form태그인 경우만 들어감

                          ex) a태그를 가르키는 셀렉터는 HTMLAnchorElement에 해당되는 자료형인지 체크해야 true가 나옴

                              let 링크 = document.querySelector('#link');

                              if (링크 instanceof HTMLAnchorElement) {
                                링크.href = 'https://kakao.com'  /
                              }

            4) any 자료형
                : 선언된 변수에 어떤 자료형(배열도 상관없음)이 들어와도 상관없는 자료형
                   -> 그냥 JS의 기본 동적타입 자료형을 주는거랑 똑같다고 보면 됨..
                      (= 비상시에는 써도 되지만, 얘를 쓰면 TypeScript를 쓸 이유가 없음) 

                       ex) any 타입으로 선언된 변수 이름에는 뭐든 들어갈 수 있음
                            -> any변수명[0], any변수명.data로도 에러가 없음
                            -> 어떤 자료형을 가진 변수에도 대입 가능함
                            
                               let 이름: any = 'kim';
                               이름 = 123;
                               이름 = undefined;
                               이름 = []; 
    
                               이름[0];    <- any는 배열로서 인식도 가능해서 문제 없음
                               이름 - 1;   <- any는 숫자로서 인식이 가능
                               이름.data;  <- any는 JS객체로서 인식도 가능해서 문제 없음
    
                               let 변수1: string = 이름;   (o)
                               let 변수2: boolean = 이름;  (o)
                               let 변수3: number = 이름;   (o)

            5) unknown 자료형
                : any랑 유사하게 선언된 변수에 어떤 자료형(배열도 상관없음)이 들어와도 상관없는 자료형이나.. 뭘 넣어도 자료형이 unknown으로 유지된다는게 다름
                   -> 그냥 JS의 기본 동적타입 자료형을 주는거랑 똑같다고 보면 됨..
                      (= 비상시에는 써도 되지만, 얘를 쓰면 TypeScript를 쓸 이유가 없음) 

                       ex) unknown 타입으로 선언된 변수 이름에도 뭐든 들어갈 수 있음
                            -> BUT! 뭘 넣어도 자료형은 unknown이라는 자료형으로 고유성이 유지됨
                            -> unknown 자료형은 다른 자료형과 호환이 되지 않기에, 타 자료형을 가진 변수에 대입하지 못함
                       
                                let 이름: unknown = 'kim';
                                이름 = 123;
                                이름 = undefined;
                                이름 = []; 

                                이름[0];    <- unknown != 배열
                                이름 - 1;   <- unknown != number
                                이름.data;  <- unknown != JS객체

                                let 변수1: string = 이름;   (x)   <- unknown 자료형은 다른 자료형과 호환이 되지 않는 고유의 자료형임
                                let 변수2: boolean = 이름;  (x)
                                let 변수3: number = 이름;   (x)

                       @ any VS unknown
                          - (공통점) 해당 자료형을 가진 변수에 어떤 자료형의 값을 넣어도 문제없음
                          - (차이점) 
                               1. any는 모든 자료형을 포괄하는 동적으로 변할 수 있는 자료형을 의미하지만, unknown은 unknown이라는 고유의 자료형을 의미함
                               2. any는 다른 자료형을 가진 어떤 변수에도 대입 가능 <-> unknown은 다른 자료형을 가진 어떤 변수에 대입이 불가능

            6) 유니언 자료형(= Union type)
                : TypeScript에서 어떤 변수에 들어갈 값이 자료형이 여러개일 때, OR을 의미하는 연산자인 '|' 과 조합하여 선언된 자료형 

                   ex) 해당 변수에는 string이나 number 자료형의 값만 할당이 가능함
                        -> (주의) 변수에 값이 할당되는 순간 Union 타입의 OR 연산자는 효력을 잃고, 변수의 자료형은 들어온 값의 자료형으로 고정됨
                   
                            let 이름: string | number = 'kim';   ->  'kim'의 자료형인 string으로 이름의 자료형은 고정
                            let 나이: (string | number) = 100;   ->  100의 자료형인 number로 나이의 자료형이 고정 

                        -> (주의) Union 타입으로 선언된 변수는 값이 들어가지 않는다면, 그 어떤 타입이라고 말할 수 없기에, 후속조치를 취할 수 없음

                            let 나이: string|number;
                            나이 + 1;                  <- 나이라는 변수는 string|number인지 확실지 않기에 사칙연산이 실행되지 않고 에러를 벹음

                   ex) 배열(Array)이나 JS객체(Object)에도 Union type을 연계해서 적용이 가능
                        -> array, object에 정의된 Union 타입의 OR 연산자는 언제나 유지됨
               
                           var 어레이: (number | string)[] = [1,'2',3]                    -> 숫자나 문자열만 받아들이는 배열도 | 연산자와 선언 가능
                           var 오브젝트: {data : (number | string) } = { data : '123' }   -> 객체의 멤버변수에 적용된 | 연산자는 언제나 효력이 유지됨

            7) 리터럴 자료형(= Literal Type)
                : 사용자가 설정한 '특정 글자나 숫자'들만 가질 수 있게 정확한 값으로 제한을 두도록 설정한, const 변수의 업그레이드와 같은 자료형
                  (typescript 컴파일러가 해당 값에 해당하는 값만 받도록 검열)
                    -> JS객체 또한 내부 프로퍼티 값을 리터럴 자료형(= Literal Type)으로 사용 가능함!  

                   @ (참고) 리터럴 자료형(= Literal Type) 예시  

                      a. 기본 리터럴 자료형(primitive Literal types)
                          : JS 변수에 자료형으로 구체적으로 지정된 값을 넣을 경우의 typescript 컴파일러가 해당 값에 해당하는 값만 받도록 검열하는 자료형을 의미

                            ex) let userName2 : 'Tim';       <- 변수 userName2에는 'Tim'이라는 문자열만 값으로 받을 수 있게 조치


                      b. JS객체 내부의 프로퍼티에 리터럴 자료형(Literal types) 사용
                          : JS 변수에 자료형으로 JS객체를 설정하고, 그 속성(프로퍼티)에 구체적으로 지정된 값을 넣을 경우에 typescript 컴파일러가 해당 값에 해당하는 값만 받도록 검열하는 자료형을 의미
                             -> 이와 같이 객체의 특정 속성명의 자료형을 fix하는 경우, 이를 Narrowing 작업에 유용하게 쓸 수 있음
                          
                                ex) let teacher : {
                                      name : string,
                                      age : 4
                                    } = { name : 'john' }    <- 해당 객체의 age는 4라는 명칭의 자료형으로 고정
                
                                ex) type 사람 = {
                                      name : string,
                                      age : 4
                                    }
                
                                    let teacher : 사람 = { name : 'john' } 

                   @ (참고) 리터럴 자료형(= Literal Type) 참고 사항

                      a. (중요!) 객체 리터럴 자료형(object literal type)과 여기서 말하는 리터럴 자료형(literal type)은 개념적으로 거의 상관관계가 없다봐도 무방함
                           : 리터럴 타입은 특정 값에 대한 제약을 주는 데 사용되고, 객체 리터럴 타입은 객체의 구조를 정의하고 검증하는 데 사용됩니다.
                               -> JS객체 리터럴 자료형(object literal type)
                                   : TypeScript에서 JS객체의 '구조'를 정의하는 데이터 자료형을 의미
    
                               -> 리터럴 자료형(literal type) 
                                   : 문자열, 숫자, 불리언 중에서도 특정한 값이 자료형 그 자체로 '제약'되는 경우의 자료형을 의미

                      b. (중요!) 유니언 자료형(= Union type)과 연계하여, 사용자가 해당 변수에 입력가능한 값을 2개 이상으로 늘리는 것도 가능함
                           -> 해당 부분이 const와의 결정적인 차이점!

                          ex) let 방향: 'left' | 'right';  <- 변수 '방향'은 left, right라는 문자열만 받을 수 있으며, 수정도 가능한 상태가 됨!

                      c. 함수(function)에서 자료형을 설정해야 하는 parameter들이나 return값에도 리터럴 자료형(= Literal Type)의 지정이 가능함

                          ex) '함수'라는 function의 parameter인 'a'는 'hello'라는 문자열만 받을 수 있고, return값은 (1 | 0 | -1)라는 문자열만 받을 수 있는 리터럴 자료형(= Literal Type)에 해당
                         
                               function 함수(a : 'hello') : (1 | 0 | -1) {
                                 return 1 
                               }

                      d. 함수를 선언할 때 써버리면 함수로서 기능이 불가능하니.. 잘못쓰는 일이 없도록 주의
                           -> 보통, TS에서 객체 선언시 그 멤버들의 자료형을 결정할 때 사용하는 type 변수에 익숙지 않은 경우, 기존 JS의 문법을 써놓고 본인은 자료형 지정을 했다고 착각하는 일이 있는데 그러지 말도록 하자

                              ex) '자료'라는 객체는 type으로 선언된게 아니라서 자료형이 지정된게 아니라, name이란 변수에 kim이라는 값이 들어가고 TS의 타입 추론(Type Inference)으로 string으로 지정됨
                                    -> BUT! '내함수'라는 함수의 parameter a라는 변수에 들어갈 수 있는 값의 자료형이 'kim'으로 선언... 
                                        -> 호출시 '자료' 객체의 name멤버를 내함수의 paramter로 넣어버리면, 'kim'이라는 자료형이 아니라 'string'이 들어온 것으로 인식해 에러처리                             

                                            var 자료 = {
                                              name : 'kim';     <- name의 자료형은 TS의 타입 추론(Type Inference)으로 string으로 추론됨
                                            };
                                            
                                            function 내함수(a : 'kim') { return a };    <- a의 자료형은 'kim'으로 지정
                                            내함수(자료.name);

                      e. JS 객체 내부 속성(프로퍼티)에 리터럴 자료형(objective Literal types)을 사용하는 경우, Type Narrowing(자료형 좁히기)를 통한 조건문 작성에 있어 큰 도움이 될 수 있음
                          -> (중요) 사용자 정의를 통해 만들어진 자료형은 typeof 연산자를 통해 자료형을 도출해봐야 object 타입으로만 나오기 때문..

                              ex) type Car = {
                                    wheel : '4개', 
                                    color : string
                                  }

                                  type Bike = {
                                    wheel : '2개',
                                    color : string
                                  }
                                  
                                  function 함수(x : Car | Bike){
                                    if (x.wheel === '4개'){
                                      console.log('the car is ' + x.color)
                                    } else {
                                      console.log('the bike is ' + x.color)
                                    }
                                  }

            8) Type Aliases(별칭) 문법으로 생성된 자료형
                : Type Aliases(별칭) 문법을 사용하여, 사용자 정의로 생성된 자료형
                    -> 2번 참고하자


    2. 새로운 자료형을 정의하기(Type Aliases(별칭) 문법)
        : (중요) 사용자가 정의한 자료형을 Type Aliases이란 이름으로 변수처럼 정의하고, 이를 변수나 객체의 자료형으로서 대입함으로서 재사용이 가능함

         # Type Aliases(별칭) 문법 유형
            1) type 타입별칭명 = 자료형;
                -> 사용자가 정의헌 자료형도 자료형 별칭(Type Aliases)으로서 변수처럼 선언하고 자료형으로 값을 대입하여 재사용이 가능함
                   ('자료형'으로 들어갈 건, 어떤 형식의 자료형(배열, JS객체, 사용자 정의 자료형 등)도 상관없고, 문법이 맞다면 뭐든 가능함)

                    ex) string , number , undefined 3가지 자료형의 특성을 모두 가지는 AnimalType이라는 자료형을 새로 선언하여, 동물이라는 변수의 자료형으로 사용

                         type AnimalType = string | number | undefined;
                         let 동물 : AnimalType;

                    ex) 유니언 자료형(= Union type)을 통해 기존에 선언된 타입별칭들인 'Name'과 'Age' 자료형들을 또 '|' 연산자를 통해, 새로운 유니언 타입을 가지는 타입별칭인 'NewOne' 생성

                         type Name = string;
                         type Age = number;
                         type NewOne = Name | Age;   <-  NewOne이란 타입별칭는 string과 number를 둘 다 가질 수 있는 자료형으로서 사용가능

            2) (중요) type 객체타입별칭명 = { 멤버변수1 : 자료형 , ... , 멤버변수n : 자료형 };
                -> 사용자가 정의한 특정 객체의 자료형도 자료형 별칭(Type Aliases)으로서 어떤 객체의 첨조 자료형으로서 재사용이 가능
                   (어떤 JS객체가 선언되고 멤버변수 값이 대입될 때, 컴파일러의 검열이 객체타입을 기준으로 이뤄진다는 말)

                    ex) string 자료형을 값으로 가지는 name과 number 자료형을 값으로 가지는 age라는 멤버변수를 둔 '사람'이라는 객체형식의 참조 자료형(= primitive types)변수명을 생성하고, teacher라는 객체변수의 자료형으로 선언 

                         type 사람 = {
                           name : string,
                           age : number,
                         }

                         let teacher : 사람 = { name : 'john', age : 20 } 

                    ex) (참고) Type Aliases(별칭) 문법이 없다면... 객체 자료형 선언과 값 대입을 이렇게 해야 함

                         let teacher : {
                           name : string,
                           age : number,
                         } = { name : 'john', age : 20 } 

            3) type 함수타입별칭명 = ( parameter1 : 자료형 , ... , parametern : 자료형 ) => 자료형;
                -> '함수'의 선언부 parameter와 return값의 자료형 구조를 자료형 별칭(Type Aliases)에 저장하여, '함수표현식(function expression)' 방식의 자료형으로 값을 대입하여 재사용이 가능함
                    (= 객체에 들어가는 함수인 메서드(method)도 함수라는 점에서, 똑같이 사용 가능함)

                     ex) 함수타입별칭명 NumOut는 함수의 멤버변수들의 자료형 정보를 담고 있는 자료형 별칭이며, 이는 '함수표현식(function expression)' 변수의 자료형으로서 쓰일 수 있음
                          -> (참고) 함수타입별칭명을 자료형으로 쓰는 변수는 내용으로 담는 함수 문법이 function(){}의 클래식한 방법이던, () => 내용의 arrow 함수 방식이건 상관없음
                              -> BUT! 선언된 함수는 반드시 '함수표현식(function expression)' 방식으로 선언된 함수여야, '함수타입별칭명'을 자료형으로 사용가능
  
                              type NumOut = (x : number, y : number ) => number;    <- 함수타입별칭명 NumOut은 반드시 함수표현식 형식으로 선언된 함수를 대입한 변수의 자료형으로만 쓰여야 함!
  
                              let ABC : NumOut = function(x,y){
                                return x + y
                              }
  
                              let 가나다 : NumOut = (x,y) => return x + y;
  
                              ABC(1,2);     // 3
                              가나다(3,4);   // 7


                     @ 함수표현식(function expression) 방식   <->  함수선언식(function declaration)
                        : function를 1급객체로 인정하는 JS에서 함수의 내용 작성하고, 이를 변수에 저장하는 식으로 함수를 선언되는 방식
                          (= function이 1급객체라는 건, 함수가 다른 함수의 parameter, return으로 쓰이거나 변수, 객체의 멤버로 저장되거나 하는게 가능하는 말..)

                          // '가나다'는 함수표현식으로 선언된 함수의 변수
                          let 가나다 : NumOut = (x,y) => return x + y;

         # Type Aliases(별칭) 문법 사용시 주의사항
            : Type Aliasese 문법으로 선언된 '타입별칭명'은 다른 변수들처럼 '재정의'가 불가능함
               -> BUT! interface 자료형을 사용한다면 변경이 가능함
                 
                   ex) type Name = string;
                       type Name = number;   <- 일반 변수들처럼 타입별칭명도 같은 이름으로 재정의 불가능함

         # (중요!) Type Aliases(별칭)와 연관된 연산자

            1) '변수명?' (= '변수명 : number | undefined' 와 같은 의미)
               : 어떤 함수(function)의 parameter or js객체형식의 자료형의 멤버변수가 자리는 있으나, 그것이 있어도 그만 없어도 그만임을 나타내고 싶은 경우 '변수명?' 이렇게 작성
                   -> JS객체 형식의 자료형을 정의시에는 굳이 '?' 연산자가 붙는 멤버변수를 뒤로 둘 필요는 없음
                       -> BUT! 나중에 생성자(constructor) 함수까지 연관되는 class 자료형이 등장한다면? 이야기는 달라짐
   
                      ex) Square라는 JS객체 형식의 자료형에는 color라는 멤버변수가 있던 없던 상관이 없음
                      
                          type Square = {
                            color? : string,
                            width : number,
                          }
                          
                          let 네모2 :Square = { 
                            width : 100 
                          }

            2) type 타입별칭명 = JS객체타입별칭명1 & JS객체타입별칭명2
                : '&' 연산자를 사용하여 연산되는 객체인 2개의 타입별칭명이 전부 JS객체 자료형이면?
                    -> 두 객체타입별칭의 멤버변수를 전부 결합하여 확장된 새로운 JS 객체형식을 새로 생성되는 타입별칭에 저장되는 자료형으로 정의함

                       ex) PositionX, PositionY라는 JS객체 형식 자료형에 대해 저장한 타입별칭들의 멤버변수 x, y 모두를 결합하여 확장 정의한 자료형을 저장하는 XandY 탄생
                            -> (참고) type 타입별칭명 = JS객체타입별칭명1  & { name : string } 형식으로도 작성 가능

                            type PositionX = { x: number };
                            type PositionY = { y: number };

                            type XandY = PositionX & PositionY   <-  type XandY = { x: number } & { y: number }로도 정의가능

                            let 좌표 :XandY = { x : 1, y : 2 }

                  @ Intersection Type (교차 타입) ( & )
                      : TypeScript에서 AND을 의미하는 연산자로 '&' 기호, 
                          -> 이를 통해 특정 변수가 참조하는 자료형에 AND조건을 가미하여, 다양한 임의 자료형으로 조합하여 선언이 가능함

    3. JS객체(class나 interface도 포함!) 자료형의 내부 멤버들의 상수화 기능
        : const는 변수에 원시 자료형이 들어가면, 상수화를 잘 유지하나.. 객체의 멤버변수에는 해당이 안된다는 슬픈 전설이 있음
          (변수만 상수화 해주는 const의 한계 보완 = JS객체 as const 문법이 생겨난 동기)
            -> 정확히는 JS객체를 저장하는 변수는 객체의 내용 그 자체가 아니라, 그 객체의 내용을 담는 메모리 위치(포인터) 주소를 저장하고 있음
               (= const로 유지될 상수화의 대상은 변수가 저장하는 메모리 주소값이지, 그 메모리에 저장된 변수의 내용이 아님) 
                
                ex) const 여친 = {
                      name : '엠버'
                    }
  
                    여친.name = '유라';  <- const 변수지만 들어간 값이 js객체라면, 멤버변수는 상수화 유지의 대상이 아님 

         1) JS객체 자료형의 내부 멤버들의 상수화를 유지해주는 예약어 readonly 
            : type 객체자료형명 = { readonly 멤버변수명1 : 자료형, ... ,   readonly 멤버변수명n : 자료형 }
               -> readonly를 달아준 멤버변수명들은 상수로서, 한번 값이 부여되면 변경이 불가능하게 잠기도록 TypeScript Complier가 지켜봄
                   -> (주의) 물론 TypeScript 검열관이 에러를 뿜는거고, 무시하고 compile된 JS로 상수화가 유지되는지 테스트해보면 그런거 없음 
    
                       ex) type Girlfriend = {
                             readonly name : string,
                           }
                           
                           let 여친 :Girlfriend = {
                             name : '엠버'
                           }
                           
                           여친.name = '유라'    <- readonly라서 에러남
  
         2) (readonly 업그레이드 버전) 선언된 JS객체의 멤버변수들의 진짜로 상수화시켜주는 as const 예약어
             : JS객체명{멤버 : 내용, ... ;} as const
                -> 선언된 JS객체의 멤버변수들을 상수화(원리를 보면 2중잠김 같은 느낌)하라는 일종의 Assertion(단언 문법)의 변종
                    - JS객체 멤버변수들 자료형 = Literal Type으로 변경
                    - JS객체 멤버변수들 각각에 readonly 붙여줘서 수정이 불가능하게 함
    
                       ex) var 자료 = {
                             name : 'kim' 
                           } as const;        <-  객체 '자료'의 멤버변수 name은 readonly 적용되어 수정이 불가능해지고, 자료형이 'kim'타입으록 고정
                           
                           function 내함수(a : 'kim') {
                           
                           }
                           내함수(자료.name)


    4. 함수(function)에 타입 지정
        : function 함수명(파라미터명1 : 자료형, ... , 파라미터명n : 자료형) : 자료형 { 표현식 내용 };
           -> 함수 선언시 parameter들과 return값의 자료형을 지정해주는 것이 가능

         # (중요!) parameter에 적용하는 응용 문법과 typescript 정리
         
            1) rest parameter(나머지 매개변수)를 typescript에 적용
                : function 함수명(...rest파라미터명 : 자료형[]){ 표현식 내용 }
    
                  ex) function 전부더하기(...a : number[]) {
                        let x = 0;
                      
                        for (let i in a) {
                          console.log(a[i]);
                          x += a[i];
                        }
                      
                        return x;
                      }
                      
                      console.log(전부더하기(1, 2, 3, 4, 5));
    
                 @ (응용) 필수적으로 들어가야하며, 갯수가 고정된 일반 parameter와 조합도 가능
                    : function 함수명(파라미터명1 : 자료형, ... , 파라미터명n : 자료형, ...rest파라미터명 : 자료형[]){ 표현식 내용 }
                       -> (중요) 필수적으로 들어가야할 parameter들이 먼저 왼쪽에 선언되고, rest parameter가 가장 나중에 선언되어야, 나중에 함수 호출시 인터프리터가 일반 parameter를 구분 가능
    
                          ex) function ab만더하고나머지곱해(x : number, y : number , ...c : number[]) {
                                let xy = x + y;
                              
                                for (let i in c) {
                                  console.log(c[i]);
                                  xy *= c[i];
                                }
                              
                                return xy;
                              }
                              
                              console.log( xy만더하고나머지곱해(1, 2, 3, 4, 5) );
               
                 @ rest parameter(나머지 매개변수) <-> Spread operator(스프레드 연산자)
                    : 'funcition'에 들어갈 parameter의 개수가 정해지지 않을 경우에 사용하는 parameter 작성 문법
                       -> 비슷한 용도로 들어갈 paramter들을 '...파라미터명'으로 입력하면, 해당 parameter는 해당 function {}안에서 JS배열로서 받아올 수 있음
    
                 @ Spread operator(스프레드 연산자) <-> rest parameter(나머지 매개변수)
                    : {JS객체}, [JS배열] 내부의 요소로 또 다른 JS객체, JS배열의 요소들을 넣고 싶을 때 사용하는 문법 (JS객체의 Spread operator는 ES2018부터 가능)
                       -> (중요) Spread operator(스프레드 연산자)를 사용하여 복사된 객체는 깊은 복사되어 원본 객체와 전혀 다른 메모리에 저장됨 (= instance 주소가 다름)
    
                            ex) JS배열의 Spread operator
                          
                                const arr1 = [0, 1, 2];
                                const arr2 = [3, 4, 5];
                                
                                const arr3 = [...arr1];                // arr3은 [0, 1, 2]
                                const arr4 = [1, 2, ...arr2, 9, 10];   // arr4는 [1, 2, 3, 4, 5, 9, 10]
                                const arr5 = [...arr1, ...arr2];       // [0, 1, 2, 3, 4, 5];
          
                            ex) JS객체의 Spread operator
                          
                                const obj1 = { name: 'John', age: '20' };
                                const obj2 = { name: 'Tom', age: '23' };
                                
                                const clonedObj1 = { ...obj1 };                                // Object { name: 'John', age: '20 }
                                const mergedObj = { ...obj1, num_of_persons : 2,  ...obj2 };   // Object { name: 'John', age: '20',  num_of_persons : 2, name: 'Tom', age: '23' }

            2) JS객체 or JS배열을 Destructuring(구조분해) 문법을 통해 parameter선언시 typescript에 적용

                a. {JS객체}의 경우
                    : function 함수명( { property1, ...  , propertyN } : JS리터럴객체 or JS객체타입별칭명 or 인터페이스명 ){ 표현식 내용 }
                       -> 물론 parameter의 property들에 상응하는 JS객체구조들 만들어놔야 Destructuring(구조분해) 문법이 통함
    
                          ex) funcition 선언시 parameter의 자료형으로 'JS리터럴객체'를 선언하는 경우

                               let person = { student : true, age : 20 };
 
                               function 함수({student, age} : {student : boolean, age : number}){
                                 console.log(student, age);
                               }
 
                               함수(person);

                          ex) funcition 선언시 parameter의 자료형으로 'JS객체타입별칭명(Type Aliases)'를 선언하는 경우

                               type UserType = {
                                 user : string,
                                 comment : number[],
                                 admin : boolean
                               }

                               function 함수({user, comment, admin} :UserType) :void{
                                 console.log(user, comment, admin)
                               }

                               함수({ user : 'kim', comment : [3,5,4], admin : false }) 

                          ex) funcition 선언시 parameter의 자료형으로 '인터페이스명'를 선언하는 경우

                               interface UserType = {
                                 user : string,
                                 comment : number[],
                                 admin : boolean
                               }

                               function 함수({user, comment, admin} : UserType) :void{
                                 console.log(user, comment, admin)
                               }

                               함수({ user : 'kim', comment : [3,5,4], admin : false }) 

                b. [JS배열]의 경우
                    : function 함수명( [요소1, ... , 요소n] : JS배열 or JS배열타입별칭명 ){ 표현식 내용 }
    
                      ex) funcition 선언시 parameter의 자료형으로 'JS배열'를 선언하는 경우
                      
                           function 함수([a,b,c] : (number | string | boolean)[]){
                             console.log(a,b,c)
                           }
                           
                           함수( [40, 'wine', false] ) 


                      ex) funcition 선언시 parameter의 자료형으로 'JS배열타입별칭명(Type Aliases)'를 선언하는 경우

                           type 어레이 = (number | string | boolean)[];
                           
                           function 함수([a,b,c] : 어레이){
                             console.log(a,b,c)
                           }
                           
                           함수( [40, 'wine', false] ) 

                 @ Destructuring(구조분해) 문법
                    : {JS객체}나 [JS배열]의 내부 요소들을 쉽게 꺼내서, 다른 '생성된 JS변수'에 대입하여 사용하는 ES6(2015)에서 추가된 문법
                       -> (중요!) 구조분해 구문을 받을 JS변수는 반드시 새로 선언되어야 함!

                           ex) {JS객체} Destructuring(구조분해)  
                                 : student, age라는 변수에 JS리터럴객체의 동명의 프로퍼티들의 값을 복사해 대입한 효과를 얻을 수 있음
 
                                   let { student, age } = { student : true, age : 20 }

                           ex) {JS배열} Destructuring(구조분해) 
                                 : a, b라는 변수에 JS배열의 각 인덱스의 값을 복사해 대입한 효과를 얻을 수 있음         
                               
                                   let [a, b] = ['안녕', 100]

         # 함수(function)의 return에만 적용 가능한 자료형
            : (중요!) 보통은 void 자료형만 사용하겠지만, 특정 상황에 never 타입이 강제로 자료형으로 주어지는 경우가 있으니 알아놓는게 좋음
         
               1) void
                  : 함수(function)에서 return할 자료가 없는 함수의 경우 해당 자료형을 사용함
                    (= void를 쓸거면, 함수에 return을 쓸 생각 하지마라)
       
                     ex) function person( name? : string, age : number ) : void { return없는 내용 };

                   @ void 자료형이 자동 할당되는 경우
                      : 함수 선언문(funcition declaration)이 return문 없이 끝났는데? 자료형이 정의되지 않는 경우
                       
                        ex) 해당 함수의 자료형은 void로 자동 할당
                        
                            function 함수(){
                              throw new Error()
                            }
    
               2) never
                  : 함수(function)에서 return할 자료가 없음 + 해당 함수 {}가 절대로 끝나지 않는 경우 해당 자료형을 사용함
                    (= void 자료형 + endpoint가 없어 함수{}를 벗어나지 못하는 함수의 경우 적용되는 자료형)
    
                     ex) return은 없지만, 함수{}를 벗어날 수 있어 never 자료형 붙이지 못하는 함수 예시
    
                         function 함수(){
                           console.log(123)
                         }
    
                     ex) 반복문 무한루프 (never 자료형에 해당되는 사례1)
    
                         function 함수() : never{
                           while ( true ) {
                             console.log(123)
                           }
                         }
    
                     ex) 에러 발생 (never 자료형에 해당되는 사례2)
    
                         function 함수() : never{
                           throw new Error('에러메세지')
                         }

                   @ never 자료형이 자동 할당되는 경우
                      : 2, 3 번의 경우는 코드의 논리에 문제가 있음을 알려주는 느낌이니 참고

                        1. 함수 표현식(funcition expression)이 return문 없이 끝났는데? 자료형이 정의되지 않는 경우
                         
                            ex) 해당 함수의 자료형은 never로 자동 할당
                            
                                let 함수2 = function (){
                                  throw new Error()
                                }
   
                        2. 함수의 parameter 대상 Type Narrowing(자료형 좁히기) 조건문 처리가 이상한 경우 
                            -> 이 경우 parameter의 자료힝이 never로 자동 할당
       
                               ex) parameter의 자료형이 string 뿐이 못 들어오는 상황인데, else문이 들어온 경우 parameter의 자료형이 never로 할당됨
                               
                                   function 함수(parameter : string) {
                                     if ( typeof parameter === "string"){
                                       parameter + 1;
                                     } else {
                                       parameter;
                                     }
                                   }

                        3. tsconfig.json에서 strict 옵션을 켜둘 경우 
                            -> any타입을 지정하지 못하게 되어, 배열같은 참조 자료형에 자료형 지정을 안 하고 선언하면 never 타입이 등장할 수도 있음


         # '변수명?' (= '변수명 : number | undefined' 와 같은 의미)
            : 어떤 함수(function)의 parameter or js객체형식의 자료형의 멤버변수가 자리는 있으나, 그것이 있어도 그만 없어도 그만임을 나타내고 싶은 경우 '변수명?' 이렇게 작성
                -> BUT! '?' 연산자가 붙는 파라미터에 대한 선언은 뒤로 몰라놔야 함 (이렇게 해야, 오버로딩된 함수 호출 시 인식에 문제가 없음)

                   ex) function person( name? : string, age : number ) : string { 내용 }; (x)  ->  이렇게 되어버리면, person(1)에서 기입된 paramter가 뭔지 알지 못해서 에러
                       function person( name : string, age? : number ) : string { 내용 }; (o) 

         # '|' 연산자를 통해 parameter나 함수 return 자료형도 '유니언 자료형(= Union type)'을 사용은 할 수 있음
             -> BUT! 유니언 자료형(= Union type)을 사용 시, 함수 표현식을 진행하다가 해당 parameter나 return값의 어떤 자료형인지 확실해야 진행할 수 있는 기능이나 연산이 발견될 시 TS에서 에러를 뿜을 수 있음

                ex) TypeScript는 '그래서 return에서 변수 x의 자료형은 뭔데? ㅅㅂ 나더러 어쩌라고' 라는 에러를 내뱉음
                      -> 꼬우면, 함수의 parameter의 갯수나 종류에 따라 오버로딩 처리라는 좋은 방법이 존재함

                         function 자릿수세기(x :number | string){    <- x의 자료형이 number일떄와 string 일떄의 동일 함수명을 오버로딩해서 선언해주면 에러걱정 안해도 됨
                            return x + 1 
                         }

         # parameter나 함수 return 자료형에 '유니언 자료형(= Union type)' 사용 시, 에러 막으려면?
            : TS선에서 해당 parameter나 return값의 자료형의 정체성을 요구할 때, 개발자는 엄격하게 그 요구를 수용해서 코드에서 자료형 파악이 확실하도록 해줘야 함
               -> 한쪽은 조건문으로 자료형에 따른 분기를 제공하고, 다른 한쪽은 특정 자료형이라고 윽박질러 위기를 모면하는거...
                  (= 정확히 코드짜려면 전자에 해당하는 Type Narrowing을 쓰도록 하자)

                  1) Type Narrowing(자료형 좁히기) 방식 사용
                      : 어떤 변수의 자료형을 찾아낼 수 있는 연산자 및 함수를 조건문(if, switch)을 사용하여, TypeScript에서 어떤 변수의 자료형을 결국 하나로 좁혀서 알 수 있다고 판단하게 도와줌
                          -> (주의!) if문을 사용한다면, else와 {}까지 완벽하게 써줘야 에러가 나지 않게 되어 있음
                               -> 그게 싫으면, tsconfig.json의 설정에 "noImplicitReturns": false를 추가

                                   ex) parameter인 변수 x값이 유니언 자료형(= Union type)으로 선언되어 있기에
                                        -> x가 가질 수 있는 자료형 경우의 수에 대한 분기에 대한 코드 진행을 하나하나 써야함
    
                                           function 내함수(x :number | string){
                                              if (typeof x === 'number') {
                                                return x + 1
                                              } 
                                              else if (typeof x === 'string') {
                                                return x + 1
                                              }
                                              else {         <- 특별히 설정하지 않는다면, Narrowing 방식 적용시 else구문은 다 써줘야 에러가 안 남
                                                return 0
                                              }
                                           }


                       @ Type Narrowing(자료형 좁히기) 방식과 연관된 자료형 판별 연산자들

                          a. typeof 변수명
                              : '변수명'의 자료형이 무엇인지를 반환함
                                  -> (중요!) 해당 변수의 자료형이 기본 자료형(primitive type)인 경우에만 통함

                                ex) function printAll(strs: string | undefined) {
                                      if (strs && typeof strs === "string") {  
                                        console.log(s);
                                      } 
                                    }

                          b. 객체명 instanceof 클래스명
                              : '객체명'의 자료형이 '클래스명'이거나 해당 '클래스명'을 상속받는 클래스인지 여부를 boolean값으로 반환함 
                                  -> 정확히는 '객체명'의 상속이력을 보여주는 'protoType(프로토타입)' 체인에 해당 '클래스명'이 있는지를 검색해 줌
                                     (class를 정의하고, 생성자를 통해 생성한 JS객체에만 적용가능)

                                     ex) let 날짜 = new Date();

                                         if (날짜 instanceof Date){
                                           console.log('참이에요')
                                         }

                          c. '속성명(property)' in 변수명(객체 자료형) 
                              : 어떤 '속성명'이 '변수명'이라는 객체 안의 속성으로서 존재하는지 여부를 boolean값으로 반환함 
                                 -> 서로 배타적인 속성을 가져와야 narrowing이 가능
                                    (= 공통된 속성명이 있다면 가급적이면 Narrowing에 사용하지 말거나, 엄격한 논리 연산자로 조건을 거는게 좋음)

                                    ex) type Fish = { swim: string };
                                        type Bird = { fly: string };
                                        
                                        function 함수(animal: Fish | Bird) {
                                          if ("swim" in animal) {
                                            return animal.swim
                                          }
                                          return animal.fly
                                        } 

                          d. JS객체명.프로퍼티명(속성명) & 비교연산자(==, !=)
                              : (중요) JS 객체 내부 속성(프로퍼티)에 리터럴 자료형(objective Literal types)을 사용하는 경우, Type Narrowing(자료형 좁히기)를 통한 조건문 작성에 있어 큰 도움이 될 수 있음
                                  -> 사용자 정의를 통해 만들어진 자료형은 typeof 연산자를 통해 자료형을 도출해봐야 object 타입으로만 나오기 때문..
                                  -> '속성명(property)' in 변수명을 쓰기에, 비슷한 명칭의 프로퍼티명(속성명)들을 가지는 JS객체 리터럴들이 많은 경우, Narrowing 처리하기 힘든 경우가 발생할 수도 있기 때문

                                      ex) Car나 Bike라는 JS객체 리터럴 자료형들은 wheel과 color라는 속성을 둘 다 가지고 있어서.. 자료형을 Narrowing하여 경우에 따라 함수의 전개를 다르게 하려는 경우 in 연산자는 도움이 안됨
                                           -> 이런 경우에 wheel 속성들을 JS객체 리터럴 별로 리터럴 자료형(literal type)을 부여하여, parameter로 들어오는 녀석의 자료형이 무엇인지를 wheel의 값과 자료형을 조건문에 넣어 판별 가능
                                      
                                          type Car = {
                                            wheel : '4개', 
                                            color : string
                                          }

                                          type Bike = {
                                            wheel : '2개',
                                            color : string
                                          }

                                          function 함수(x : Car | Bike){
                                            if (x.wheel === '4개'){
                                              console.log('the car is ' + x.color)
                                            } else {
                                              console.log('the bike is ' + x.color)
                                            }
                                          }

                       @ falsy 값 개념
                          : false와 유사한 기능을 하는 null, undefined, NaN 이런 값들을 의미
                             
                             - falsy값과 비교 연산자(==, !=, <> , <=>)
                                : 해당 null, undefined, NaN값들은 엄격한 === 연산자를 쓰는게 아니면, 비교 연산자로 비교시 자동 형변환을 통해 같은 계열로 인식
                             
                             - falsy값과 논리 연산자(&&, ||) 
                                : 논리 연산자와 연관된 해당 null, undefined, NaN값들은 false값과 동일한 것으로 인정됨

                       @ null & undefined 체크하는 코드 1줄로 줄일 때 사용가능한 문법들

                         a. optional chaining 문법 구조체(syntax construct) 사용
                            -> (주의) 조건식에 어떤 js객체의 '프로퍼티'가 들어갈 때에 사용이 가능

                                ex) let 제목 = document.querySelector('#title');

                                    if (제목?.innerHTML != undefined) {
                                      제목.innerHTML = '반갑소'
                                    }
                         
                         b. 논리 연산자 && 사용

                            ex) function printAll(strs: string | undefined) {
                                  if (strs && typeof strs === "string") {  
                                    console.log(s);
                                  } 
                                }

                            ex) let 제목 = document.querySelector('#title');
                         
                                if (제목 != null && 제목.innerHTML != undefined) {
                                  제목.innerHTML = '반갑소'
                                }

                         c. 3항연산자 문법 사용

                            ex) function printAll(strs: string | undefined) {
                                  if (strs? typeof strs === "string") {  
                                    console.log(s);
                                  } 
                                }

                            ex) let 제목 = document.querySelector('#title');
                         
                                if (제목? 제목.innerHTML != undefined) {
                                  제목.innerHTML = '반갑소'
                                }

                       @ optional chaining 문법 구조체(syntax construct) '변수?.'
                          : 대상 '변수' or '객체' or '멤버변수'가 null이나 undefined이면? boolean값에 따라 값이 달라짐 (3항 연산자랑 유사하나 다름)
                             -> true : undefined 반환하고, 후속 멤버변수 체이닝 접근 중단 (= 더 깊게 가서 null 에러 내지 않게 도와줌)
                             -> false :해당 '변수'나 '멤버변수'의 값 
               
                                ex) let user = null;
                                    alert( user && user.address && user.address.street );  // 과거에는 &&사용, 문제 있으면 undefined에서 중단
                                    alert( user? user.address? user.address.street : undefined : undefined;
                                    alert( user?.address );                                // undefined에서 마무리되고, address 멤버변수는 보지도 않음
                                    alert( user?.address.street );                         // undefined
               
                                ex) 이벤트리스너 부여하는것 또한, optional chaining 문법을 응용할 수 있음
               
                                    let 버튼 = document.getElementById('button');
               
                                    버튼?.addEventListener('click', function(){
                                      console.log('안녕')
                                    }) 


                  2) Type Assertion(자료형 단언하기) 방식 사용
                      : '변수명 as 자료형' 구문으로 '해당 변수의 자료형은 정확히 무엇이라고 주장한다'는 의미를 TypeScript에 단서 제공
                          -> BUT! 어디까지나 자료형이 무엇이다라고 개발자가 주장하는거지 fix하는건 아님!
                             (= 극단적으로는 TypeScript를 속여 검열만 피하고, Type Assertion한 자료형이 아닌 값이 들어오게 할 수도 있음)

                              ex) return문에 parameter 변수 x의 자료형은 '숫자'라고 TypeScript 검열관에게 윽박지를 뿐.. 
                                  (= 내함수('문자열'); 코드도 결국 형변환 없이 실행되는 진풍경을 볼 수 있음)
                              
                                   function 내함수(x :number | string){ 
                                       return (x as number) + 1 
                                   }
    
                                   console.log( 내함수(123) );     <- 숫자 123이 들어갔으니 124는 정상출력
                                   console.log( 내함수('123') );   <- 문자 '123'이 들어가도, 숫자로 캐스팅을 해주는건 아니니.. 저항없이 '1234'라는 문자열 출력 (TypeScript 검열관이 손을 놓음)

                       @ (중요!) as 예약어의 의미
                          : union type 같은 복잡한 자료형을 하나의 정확한 자료형으로 줄이는 역할을 수행한다지만..
                             -> 현실은 TypeScript의 자료형 검열을 윽박질러 피하는 눈속임에 불과함
                                 (= as를 남발한다? TypeScript의 엄격한 타입체크기능을 잠깐 안쓰겠다는 뜻과 동일)

                       @ 예전 Type Assertion 문법
                          : '<자료형>변수명'
                              -> component 위주의 프론트엔드 라이브러리 환경인 react나 vue.js에서는 <> 기호가 뭘 의미하느지 헷갈리게 하기에 as키워드를 쓰게 됨

                       @ Type Assertion의 as 문법을 쓰는 경우
                         a. 타입 에러의 원인을 모를 때, 임시방편으로 사용
                         b. 어떤 자료형만 들어올지 정말 확실하게 알고 있는데, TypeScript의 컴파일러 에러가 방해할 때 사용
                         c. paramter를 넣으면, 특정 자료형을 강제로 부여하는 함수를 제작할 경우 

                             ex) 변환기<자료형>('문자열') 라는 함수는 제너릭스에 '자료형'을 넣고, Json형식의 데이터를 paramter로 넣으면?
                                  -> JS객체로 반환하고, 그 반환된 객체가 해당 '자료형'을 가지고 있다고 TypeScript에게 주장시켜 인지시킴
                             
                                     type Person = {
                                         name : string
                                     }

                                     function 변환기<T>(data: string): T {
                                         return JSON.parse(data) as T;
                                     }

                                     const jake = 변환기<Person>('{"name":"kim"}');    <- JS객체는 Person이란 객체를 자료형으로 가지고 있다고 TypeScript는 가스라이팅 당하게 됨


    5. 인터페이스(interface) 문법 기능
        : 어떤 객체의 추상적인 명세서에 해당하는 interface문법을 JS기반 언어에서도 사용이 가능!

         # (참고) TypeScript에서 인터페이스(interface) 문법을 쓰는 이유?

            a. Type Aliases에 비해 용도가 확실함
                : Type Aliases와 유사하지만, 이 문법 하나로 변수에 JS객체(object), 함수 표현식(function expression), 클래스(class) 구조에 한해서 설계하고 선언할 때, 이걸로 다 퉁치는게 가능하기 때문
   
            b. 제한적이나마 객체지향과 유사한 '확장(extend)', '구현(implements)'를 사용 가능
                : 개발자 입장에서 js객체나 class 자료형 관적인 이해 + 상대적으로 엄격한 Type Aliases에 비해 유연함을 가지고 코드 운영이 가능
                    -> BUT! 때떄로 엄격한 검열이 더 중요할 수 있다는 점에서 Type Aliases와 경쟁관계 X, 보완관계 O


         # 인터페이스(interface) 문법 VS Type Aliases(별칭) 문법
            - 공통점 
               : readonly, '?' 연산자, '&' 연산자 사용 가능

            - 차이점 
               1) 일반 자료형 선업 가능 범위 
                   -> interface    : 사용자 정의 자료형이지만, JS객체 리터럴(object literal), 함수 표현식(function expression)의 자료형에 사용가능
                   -> Type Aliases : 모든 자료형을 베이스로 포괄적인 자료형을 생성이 가능함

               2) 변수의 '재정의' 가능?
                   -> interface    : 가능 (중복시 extends 한 것이랑 동일하게 유연히 동작)
                     
                      ex) interface명 재정의시, 이전 내용에 +@를 한 유연한 효과가 남 
                          (= interface Animal extends Animal 한 것과 같이, name과 legs속성을 Animal이란 interface는 가지게 됨)
                      
                          interface Animal { 
                            name :string 
                          } 
                          
                          interface Animal { 
                            legs :number 
                          }

                   -> Type Aliases : 불가능

                      ex) type Name = string;
                          type Name = number;   <- 일반 변수들처럼 타입별칭명도 같은 이름으로 재정의 불가능함

               3) 확장을 위한 extend, class로의 구현을 위한 implements
                   -> interface    : 가능
                   -> Type Aliases : 불가능

         # 인터페이스(interface) 선언 & 자료형으로 사용하는 문법
            1) 사용자 정의 JS객체(object) 리터럴 형식 인터페이스(interface)
            
               - JS객체(object) 인터페이스(interface) 선언
                  : interface 인터페이스명 { 프로퍼티1 : 자료형, ... , 프로퍼티n : 자료형 };
                     -> (참고) ',' 대신 ';'로 프로퍼티들 선언에 써도 상관없음

               - JS객체(object) 인터페이스(interface) 자료형으로 사용
                  : let or const 변수 : 인터페이스명 = {프로퍼티1 : '값1', ... , 프로퍼티n : '값n'}; 

                    ex) User라는 인터페이스를 user라는 js객체의 자료형으로 정의하여, 코딩시 해당 객체의 완성도를 높이는거 가능

                        interface User {
                          name : string;
                          age : number;
                          gender? : string;             // gender의 경우는 User를 실제 구현할때 없어도 그만이다
                          readonly birthYear : number;  // readonly 속성이 붙은 녀석은 구현 후 값 수정이 불가함
                          [grade : number] : Score;     // 선언해둔 type에 해당하는 값을 타입으로 지정 가능     ex) 숫자 : Score의 문자열만 가능;
                        }
                        
                        let user : User = {
                          name : 'xx',
                          age : 30,
                          birthYear : 2000,
                          1 : 'A',
                          2 : 'B'
                        }

            2) 함수 표현식(function expression) 형식 인터페이스(interface)

               - 함수 표현식(function expression) 인터페이스(interface) 선언
                  : interface 인터페이스명 {  (parameter1 : 자료형, ... , parameterN : 자료형) : 자료형;  }

               - 함수 표현식(function expression)의 변수 부분에 자료형으로 사용
                  : let or const 변수 : 인터페이스명 = {프로퍼티1 : '값1', ... , 프로퍼티n : '값n'}; 

                    ex) Add라는 2개의 number 파라미터와 return 자료형이 number를 반환하는 구조의 함수형 인터페이스명을 add라는 함수 표현식의 자료형으로 지정

                        interface Add {
                          (num1 : number, num2 : number) : number;   
                        }
                        
                        const add : Add = function(x, y) {
                          return x + y;
                        }
                        
                        add(10, 20);

         # (중요) interface 내용 확장시 사용하는 extends & class 구현시 사용하는 implements 예약어
         
            1) extends
                : 작성된 interface를 상속하여, 그 interface들에 존재하는 자료형들만 존재하는 프로퍼티와 추상 메서드들을 기반으로 다른 interface로 '확장'하는 예약어

                  @ (중요) extends 관련 주의사항
                     a. class와 다르게, interface를 선언시에는 2중 동시상속을 쓸 수 있음

                     b. 확장한 interface는 extends로 가져간 선조 interface의 프로퍼티들을 다 가지게 됨
                        (= 확장한 interface를 자료형으로 선언한 JS객체 리터럴을 받는 변수는 선조의 프로퍼티, 메서드 또한 다 가지고 있어야 함)

                     c. (중요!) extends를 쓸 떄, 확장한 interface가 선초 interface의 프로퍼티를 중복해서 가지고 있으면? 짤 없이 에러남
                         -> '&' 연산자와의 중대한 차이이며, 조금 더 중복에 대해 엄격!
                  
                  ex) 예시를 위해 선언된 interface (= 이걸로 extends들의 예시를 들 예정)

                      interface Car {
                        color : string;
                        wheels : number;
                        start() : void;
                      }

                      interface Toy {
                        name : string;
                      }

                  ex) 단일 interface의 상속 사례에 해당하는 Benz라는 interface

                      // Car라는 interface를 상속받아 확장한 Benz라는 interface
                      interface Benz extends Car {
                        door : number;
                        stop() : void;
                      }
                      
                      const benz : Benz = { 
                        color : 'red',
                        wheels : 4,
                        start(){
                          console.log('gogo');
                        },
                        door : 5,
                        stop(){
                          console.log('stop');
                        }
                      }

                  ex) 복수의 interface를 상속하는 사례에 해당하는 ToyCar라는 interface

                      // car와 toy의 동시에 상속받은 ToyCar라는 interface (두 인터페이스의 프로퍼티, 메서드를 전부 가져야 함)
                      interface ToyCar extends Car, Toy {   
                        price : number;
                      }
                      
                      const toyCar : ToyCar = {
                        color : 'blue',
                        wheels : 4,
                        start(){
                          console.log('gogo');
                        },
                        name : "toycar",
                        price : 111,
                      }

                  ex) 선조 interface Toy의 프로퍼티 name을 중복해서 가지는 errorToy라는 interface
                       -> 짤 없이 TypeScript 컴파일러가 에러를 잡음

                          interface errorToy extends Toy {
                            name : string;   <- Toy도 가지고 있는 프로퍼티
                            useless : null;
                          }

            2) implements
                : 작성된 interface를 기반으로, 그 interface들에 존재하는 자료형들만 존재하는 프로퍼티와 추상 메서드들을 기반으로 다른 class로 '구현'하는 예약어

                  @ (중요) implements 관련 주의사항
                     a. class에다가만 사용가능
                     b. class를 선언시에 interface를 구현하게 된다면, 복수상속이 불가능함
                     c. 구현한 class 역시, implements로 구현에 사용한 interface의 프로퍼티들을 다 가지게 됨
                        (= 구현한 class 생성자를 이용해서 생성한 JS객체를 받는 변수는 선조의 프로퍼티, 메서드 또한 다 가지고 있어야 함)

                  ex) 예시를 위해 선언된 interface 

                      interface Car {
                        color : string;
                        wheels : number;
                        start() : void;
                      }

                  ex) Car interface를 구현한 Bmw라는 class  

                      interface Car {
                        color : string;
                        wheels : number;
                        start() : void;
                      }

                      // 상단의 Car 인터페이스 class로 구현 
                      class Bmw implements Car {
                        color;
                        wheels = 4;
                      
                        // 생성자 구현
                        constructor(c : string){
                          this.color = c;
                        }
                      
                        start() {
                          console.log('부릉부릉');
                        }
                      
                      }

         # 인터페이스(interface)와 연관된 연산자
            : Type Aliases(별칭)에서 쓰는 내용과 유사하나, 한편으로는 확장성이 넓다고도 볼 수 있음

             1) '변수명?' (= '변수명 : number | undefined' 와 같은 의미)
                : 어떤 interface의 멤버변수가 자리는 있으나, 그것이 있어도 그만 없어도 그만임을 나타내고 싶은 경우 '변수명?' 이렇게 작성
                    -> JS객체 형식의 자료형을 정의시에는 굳이 '?' 연산자가 붙는 멤버변수를 뒤로 둘 필요는 없음
                        -> BUT! 나중에 생성자(constructor) 함수까지 연관되는 class 자료형이 등장한다면? 이야기는 달라짐
    
                       ex) Square라는 JS객체 형식의 자료형에는 color라는 멤버변수가 있던 없던 상관이 없음
                       
                           interface User {
                             name : string;
                             age : number;
                             gender? : string;             // gender의 경우는 User를 실제 구현할때 없어도 그만이다
                             readonly birthYear : number;  // readonly 속성이 붙은 녀석은 구현 후 값 수정이 불가함
                             [grade : number] : Score;     // 선언해둔 type에 해당하는 값을 타입으로 지정 가능     ex) 숫자 : Score의 문자열만 가능;
                           }
                           
                           let user : User = {
                             name : 'xx',
                             age : 30,
                             birthYear : 2000,
                             1 : 'A',
                             2 : 'B'
                           }

                           user.age = 10;
                           user.gender = "male";     // 도중에 추가해도 아무 문제 없음
 
             2) let 변수 : 인터페이스명1 & 인터페이스명2 = { 인터페이스1프로퍼티 : '값', ... , 인터페이스2프로퍼티 = '값'}
                 : interface를 자료형으로 받는 JS객체 리터럴을 저장하는 변수의 경우, '&' 연산자를 사용하면 2개의 interface를 동시상속 확장하여 extends 선언된 interface를 자료형을 받는듯한 효과를 얻을 수 있음
                    -> (중요!) '&'를 통한 유사 2중 동시상속 또한 extends와 비슷하기에, 인터페이스명1과 인터페이스명2의 '프로퍼티(멤버변수, 메서드)'를 중복해서 가지고 있으면? 짤 없이 에러남

                        ex) interface Student와 Teacher의 모든 프로퍼티를 가지는 interface 자료형을 참고한 JS객체 리터럴의 참조값을 가지는 '교직원'라는 이름의 변수
                             -> (참고) 복수의 인터페이스 동시 확장할 때 쓰는 interface 인터페이스명 extends 인터명1, 인터명2;를 통해서도 비슷한걸 구현 가능
                                 -> (중요!) 역시! 언급된 interface의 모든 프로퍼티가 들어가야 에러가 안 생김
 
                                     interface Student {
                                       name :string,
                                     }
        
                                     interface Teacher {
                                       age :number
                                     }
                                     
                                     let 교직원 : Student & Teacher = { name : 'kim', age : 90 }
 
                   @ Intersection Type (교차 타입) '&'
                       : TypeScript에서 AND을 의미하는 연산자로 '&' 기호를 통해 extends를 사용하는 효과를 낼 수 있음


    6. (class 선언시에 한해) 접근제한자(Access Modifier) 사용 가능
        : class 생성자 문법을 통해, class 자료형으로 생성된 JS객체 내부의 프로퍼티(멤버변수), 메서드 들에 대한, 접근 및 수정에 대한 권한을 통제하기 위한 키워드
           -> (중요) 반드시 class 선언시 그 내부의 프로퍼티, 메서드들에만 접근제한자가 사용 가능
               -> BUT! 메서드의 parameter에 한해서 public 키워드는 사용이 가능함

         # 접근제한자(Access Modifier)를 굳이 쓰는 이유?
            : 때때로 개발 중에 실수로라도 건들고 싶지 않는 안전장치가 필요하다고 생각이 들거나, 객체 및 class 내부 구조를 혹시라도 외부에 공개되는 사태를 막고 싶은 경우가 있기 때문

         # TypeScript에서 사용 가능한 접근제한자(Access Modifier)들
            1) public 
                : 해당 접근제어자가 붙은 class를 통해 생성된 JS객체의 '프로퍼티', '메서드'는 어디서나 접근이 가능 + 수정 + 호출 가능 
                   -> (중요) 보통 아무런 접근제어자가 붙지 않은 class의 '프로퍼티', '메서드'는 자동으로 TypeScript 컴파일러는 public을 붙이게 됨

                @ (참고) 특이한 public 사용 사례
                   a. public 키워드는 class 내의 prototype 함수에도 붙일 수 있음
                   b. 메서드의 parameter에도 붙일 수 있음 
                      (= 이는 parameter가 곧 class의 내부 프로퍼티임을 의미하며, 생성자 함수에 this.프로퍼티명을 생략이 가능)

                      ex) 상단, 하단의 의미는 같지만, public 프로퍼티를 통해 생성자 내부에 this.name = name을 쓰지 않아도 바로 알잘딱깔센하게 name 프로퍼티를 인식하고 값을 입력받음
                      
                          class Person { 
                            name;
                            constructor ( name :string ){  
                              this.name = name;
                            } 
                          }

                          let 사람1 = new Person('john')

                          class Person { 
                            constructor ( public name :string ){  
                            
                            } 
                          }

                          let 사람1 = new Person('john')
            2) private
                : 해당 접근제어자가 붙은 class를 통해 생성된 JS객체의 프로퍼티, 메서드는 class{} 내부에서만 접근이 가능 + 수정 + 호출 가능 
                   -> (참고) JS에서도 '#' + 프로퍼티명을 통해 해당 접근제어자를 붙일 수 있음!

                @ (중요) getter, setter 패턴
                    : 일반적인 방향으로 접근이 안되는 private 프로퍼티를 수정하고 싶다면?
                       -> public 메서드를 선언하고 거기서 private 프로퍼티를 접근 or 수정하는 getter, setter 패턴을 사용하면 class{}안에서 접근하는 셈이니 문제 없음
                       
                          ex) changeSecret()라는 setter 함수를 통해 private한 familyName 프로퍼티의 값을 변경하는 패턴의 예시
                          
                              class User {
                                public name :string;
                                private familyName :string;
                              
                                constructor(){
                                  this.name = 'kim';
                                  let hello = this.familyName + '안뇽';
                                }
                                changeSecret(){
                                  this.familyName = 'park';
                                }
                              }

                              let 유저1 = new User();
                              유저1.familyName = 'park';  //에러남
                              유저1.changeSecret()        //가능

            3) protected
                : 해당 접근제어자가 붙은 class를 통해 생성된 JS객체의 프로퍼티, 메서드는 class{} 내부와 extends로 상속된 class{} 내부에서도 접근이 가능 + 수정 + 호출 가능 
                  (= class 상속 관계를 구현하는 과정에서 상속되는 부모class의 프로퍼티를 가져다 쓸 용도로 사용되는 접근제어자다 이 말임)

                  ex) 부모class인 User의 내부 프로퍼티인 x가 protected 접근제어자를 달고 있기에, 자식class인 NewUser의 내부{}에서 변수 x에 접근해도 문제없음
                  
                      class User {
                        protected x = 10;
                      }
                      
                      class NewUser extends User {
                        doThis(){
                          this.x = 20;
                        }
                      }


    7. (class 선언시에 한해) 정적 속성의 static 키워드 사용 가능
        : class 전체에서 공유하는 프로퍼티나 메서드에 해당하는 정적 속성 static 키워드를 사용하여 '정적 프로퍼티(속성)'과 '정적 함수' 선언가능

         # static 속성, static 메서드가 쓰이는 이유?
            : 때때로 class 전체가 공유하는 프로퍼티나 JS객체 인스턴스 없이도 접근가능한 메서드를 사용하고 싶기 때문
               <-> class로 생성된 개별 JS객체들이 각각 자신들만의 고유한 프로퍼티값 및 메서드들이 존재하는 힙영역의 포인터값을 가지고 있는 것과 다름

               ex) class 내부에 간단한 메모, 기본 설정값 입력, class로 부터 생성되는 object가 사용할 필요가 없는 변수들을 만들어놓고 싶을 때 사용

         # static 속성 선언 및 호출법

            - static 선언
               1) static 프로퍼티
                   : class 클래스명 { static 프로퍼티명 : 자료형 = '값' }

               2) static 메서드
                   : class 클래스명 { static function 함수명(...parameter){ static 프로퍼티만 관여가능한 함수 내용부 } }

            - static 호출
               : 반드시, 해당 클래스명.XXX 형식으로 호출해야 함
                 (= 상속관계에 있는 자식class로도 호출이 불가능함)

                 1) static 프로퍼티
                     : 클래스명.프로퍼티명
  
                 2) static 메서드
                     : 클래스명.메서드명(...parameter);

             ex) class ClassExample {
                  public static count: number = 0;
                
                  public static setCount() {
                    this.count += 1;
                    console.log(`count: ${this.count}`)
                  } 
                }
                
                ClassExample.setCount(); // count: 1
                ClassExample.setCount(); // count: 2
                ClassExample.setCount(); // count: 3


         # static 속성 사용시 유의사항
            1) extends 로 class를 복사할 경우 static 붙은 것들도 따라옴
            2) static 속성은 접근제어자에 해당하는 private, protected, public 키워드와 동시 사용가능
            3) (중요!) static 속성을 가진 프로퍼티, 메서드는 클래스명 그 자체가 아닌 생성자로 생겨난 JS객체 인스턴스가 호출하면 에러남

               ex) classExample1는 ClassExample의 생성자로 인해 생성된 JS객체라 static 메서드 호출이 불가능함

                   class ClassExample {
                     public static count: number = 0;
                   
                     public static setCount() {
                       this.count += 1;
                       console.log(`count: ${this.count}`)
                     } 
                   }
                   
                   var classExample1 = new ClassExample();
                   classExample1.setCount();

            4) 상속이 이뤄줘도, 자식class는 부모class의 static 프로퍼티와 메서드를 가지지 않음
               (= (중요) 부모의 static 프로퍼티나 메서드에 접근하려면 해당 '선조클래스명'의 체이닝을 통해서만 접근 가능!)

            5) static 메서드는 static 프로퍼티의 수정에만 관여가능
               (= static 메서드로는 일반 class 프로퍼티는 건들수 없고, 메서드도 static 프로퍼티를 건들 수 없음) 
                   -> 대충 깍뚜기는 깍뚜기 세계에서.. 경찰은 경찰세계에서만 산다..고 기억해라


 - TypeScript에서 ES6 이후 등장한 JS의 모듈 시스템 import & export를 통해 만든 타입변수를 다른 파일에서 사용하는 요령
    : 자세한 이야기는 JS모듈 시스템을 참고
       1) 다른 파일에서 사용하고 싶은 변수나 함수 정의 부분 왼쪽에 export 키워드를 붙이는 export 문법으로 대상 변수, 함수들을 내보내가
       2) import 문법으로 export한 다른 파일의 변수, 함수들을 가져오기   

          ex) a.ts -> b.ts 이렇게 정의된 타입을 가져다 쓰고 싶은 경우 

              (a.ts)
              
              export type Name = string | boolean;
              export type Age = (a :number) => number;
              
              (b.ts)
              
              import {Name, Age} from './a'
              let 이름 : Name = 'kim';
              let 함수 : Age = (a) => { return a + 10 } 


      # 과거의 TypeScript가 택한 방법 'namespace'
         : <script src=""> 이걸 여러개 써서 파일들을 첨부하게 되면, 변수명이 겹치는 위험이 발생하였기에.. 
            -> 이를 namespace형식(과거에는 module이라고 씀)의 JS객체를 정의해서, 그 객체의 프로퍼티로 export할 변수 및 함수들을 export하여 변수명이 겹치는 문제를 방지함 
                1) namespce형식의 JS객체를 선언하고, 그 안에 다른 파일에서 사용하고 싶은 변수나 함수 정의 부분 왼쪽에 export 키워드를 붙이는 export 문법으로 대상 변수, 함수들을 그 namespace의 프로퍼티로 삼음
                2) <reference path="./a.ts" />로 export한 다른 파일의 변수, 함수들을 가져오기   
                3) '네임스페이스명.타입명'으로 namespace의 프로퍼티인 타입명을 호출하여, 자료형 정의할 때 사용하기 

                    ex) a.ts -> b.ts 이렇게 정의된 타입을 가져다 쓰고 싶은 경우 

                        (a.ts)
                        
                        namespace MyNamespace {
                          export interface PersonInterface { age : number };
                          export type NameType = number | string;
                        } 
                                                
                        (b.ts)
                        
                        <reference path="./a.ts" />
                        
                        let 이름 : MyNamespace.NameType = '민수';
                        let 나이 : MyNamespace.PersonInterface = { age : 10 };
                        
                        type NameType = boolean;       // a.ts에 있었던 type Aliases인 NameType 사용 + 수정 가능
                        interface PersonInterface {}   // a.ts에 있었던 interface인 PersonInterface 사용 가능 (interface는 재정의 해도 expends 효과가 일어남)


 - TypeScript로 HTML을 조작할 시 에러나면 주의할 사항
    :  let 제목 = document.querySelector('#title');      <- DOM셀렉터를 담는 변수 '제목'에 자료형 정의X, 이러면 자료형을 Element로 추론(Type Inference)해서 줌 
       제목.innerHTML = '반갑소'                          <- html을 못찾을 경우 '제목' 변수의 자료형이 주어진 자료형과 다르게 null이라는 점에서, '제목이라는 변수가 null일 수 있습니다'는 error 발생

       1. Type Assertion (자료형 단언) 방식을 사용하여, TypeScript 컴파일러에 해당 변수는 무조건 DOM변수가 들어온다고 가스라이팅 하기
     
          ex) '제목' 변수에 든 값이 HTMLElement 자료형이라고 가스라이팅하여, null체크 관련 검열을 넘어가기
          
              let 제목 = document.querySelector('#title') as HTMLElement;
              제목.innerHTML = '반갑소'
     
       2. 조건문을 사용해 자료형마다 코드 진행 분기를 제공하는, Type Narrowing(자료형 좁히기) 방식 사용
          
          (1) null체크를 조건문에 사용
              
              ex) let 제목 = document.querySelector('#title');
     
                  if (제목 != null) {
                    제목.innerHTML = '반갑소'
                  }
     
          (2) '변수명 instanceof HTMLElement'을 통한 true/false 여부를 조건에 사용
     
              ex) let 제목 = document.querySelector('#title');
     
                  if (제목 instanceof HTMLElement) {
                    제목.innerHTML = '반갑소'
                  }
     
              @ (주의) 대부분의 DOM셀렉터는 HTMLElement나 Element를 자료형으로 가지지만, a태그 div, span 등의 태그는 고유의 자료형을 가질 수 있으니 이를 주의해야함
                 -> TypeScript의 DOM 자료형 부분 참고
     
          (3) 옵셔널 체이닝 '변수?.' or '&&를 통한 AND 조건' or '3항연산자'를 narrow 조건에 사용하여 null체크를 더 확실히 하기
     
              ex) let 제목 = document.querySelector('#title');
     
                  if (제목?.innerHTML != undefined) {
                    제목.innerHTML = '반갑소'
                  }
     
                  if (제목 != null && 제목.innerHTML != undefined) {
                    제목.innerHTML = '반갑소'
                  }

                  if (제목? 제목.innerHTML != undefined) {
                    제목.innerHTML = '반갑소'
                  }

              @ optional chaining 문법 구조체(syntax construct) '변수?.'
                 : 대상 '변수' or '객체' or '멤버변수'가 null이나 undefined이면? boolean값에 따라 값이 달라짐 (3항 연산자랑 유사하나 다름)
                    -> true : undefined 반환하고, 후속 멤버변수 체이닝 접근 중단 (= 더 깊게 가서 null 에러 내지 않게 도와줌)
                    -> false :해당 '변수'나 '멤버변수'의 값 
     
                       ex) let user = null;
                           alert( user && user.address && user.address.street );  // 과거에는 &&사용, 문제 있으면 undefined에서 중단
                           alert( user? user.address? user.address.street : undefined : undefined;
                           alert( user?.address );                                // undefined에서 마무리되고, address 멤버변수는 보지도 않음
                           alert( user?.address.street );                         // undefined
     
                       ex) 이벤트리스너 부여하는것 또한, optional chaining 문법을 응용할 수 있음
     
                           let 버튼 = document.getElementById('button');
     
                           버튼?.addEventListener('click', function(){
                             console.log('안녕')
                           }) 